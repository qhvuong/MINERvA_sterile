     1	#include "PlotUtils/FluxReweighter.h"
     2	
     3	#include "PlotUtils/MnvH1D.h"
     4	#include "PlotUtils/MnvH2D.h"
     5	#include "PlotUtils/MnvFluxConstraint.h"
     6	#include "PlotUtils/MnvVertErrorBand.h"
     7	
     8	#include "TMatrixD.h"
     9	#include "TMatrixDEigen.h"
    10	#include "TDecompChol.h"
    11	#include "TVectorD.h"
    12	#include "TRandom3.h"
    13	#include "TSystem.h"
    14	#include "TFile.h"
    15	#include "TH1D.h"
    16	#include "TObjString.h"
    17	#include "TDirectory.h"
    18	
    19	#include <iostream>
    20	#include <cstdlib> // For exit()
    21	#include <vector>
    22	#include <string>
    23	#include <algorithm> // tolower()
    24	
    25	namespace {
    26	  inline std::vector<TH1D*> GetVector(PlotUtils::MnvH1D* h)  {
    27	    return std::vector<TH1D*>();
    28	  }
    29	
    30	    inline std::vector<TH2D*> GetVector(PlotUtils::MnvH2D* h)  {
    31	      return std::vector<TH2D*>();
    32	    }
    33	
    34	  inline TH1D* NewHist(const TH1D& h) {
    35	    return new TH1D (h);
    36	  }
    37	
    38	  inline TH2D* NewHist(const TH2D& h) {
    39	    return new TH2D (h);
    40	  }
    41	
    42	  PlotUtils::FluxReweighter* _flux_reweighter(std::string plist,int nu_pdg,
    43	                                              bool use_nuE_constraint,
    44	                                              int n_flux_universes) {
    45	    if (plist == "minerva1") {
    46	      return new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
    47	                                         plist,
    48	                                         PlotUtils::FluxReweighter::gen2thin,
    49	                                         PlotUtils::FluxReweighter::g4numiv5,
    50	                                         n_flux_universes  );
    51	    }
    52	    else if (plist == "minerva5") {
    53	      return new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
    54	                                         plist,
    55	                                         PlotUtils::FluxReweighter::gen2thin,
    56	                                         PlotUtils::FluxReweighter::g4numiv5,
    57	                                         n_flux_universes  );
    58	    }
    59	    else if (plist == "minerva7") {
    60	      return new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
    61	                                         plist,
    62	                                         PlotUtils::FluxReweighter::gen2thin,
    63	                                         PlotUtils::FluxReweighter::g4numiv5,
    64	                                         n_flux_universes  );
    65	    }
    66	    else if (plist == "minerva9") {
    67	      return new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
    68	                                         plist,
    69	                                         PlotUtils::FluxReweighter::gen2thin,
    70	                                         PlotUtils::FluxReweighter::g4numiv5,
    71	                                         n_flux_universes  );
    72	    }
    73	    else if (plist == "minerva13" || plist == "minerva13C" || plist == "minerva13c"|| plist == "minerva13E"|| plist == "minerva13e" ) {
    74	      return new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
    75	                                         "minerva13",
    76	                                         PlotUtils::FluxReweighter::gen2thin,
    77	                                         PlotUtils::FluxReweighter::g4numiv5,
    78	                                         n_flux_universes  );
    79	    }
    80	    else if (plist == "2p2h") {
    81	      return new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
    82	                                         "minerva2p2h",
    83	                                         PlotUtils::FluxReweighter::gen2thin,
    84	                                         PlotUtils::FluxReweighter::g4numiv5,
    85	                                         n_flux_universes  );
    86	    }
    87	    else if(plist == "minervame1a" || plist == "minervame1A"){
    88	      return
    89	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
    90	                                         plist,
    91	                                         PlotUtils::FluxReweighter::gen2thin,
    92	                                         PlotUtils::FluxReweighter::g4numiv6,
    93	                                         n_flux_universes );
    94	    }
    95	    else if(plist == "minervame1b" || plist == "minervame1B"){
    96	      return
    97	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
    98	                                         plist,
    99	                                         PlotUtils::FluxReweighter::gen2thin,
   100	                                         PlotUtils::FluxReweighter::g4numiv6,
   101	                                         n_flux_universes );
   102	
   103	    }
   104	    else if(plist == "minervame1c" || plist == "minervame1C"){
   105	      return
   106	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
   107	                                         plist,
   108	                                         PlotUtils::FluxReweighter::gen2thin,
   109	                                         PlotUtils::FluxReweighter::g4numiv6,
   110	                                         n_flux_universes );
   111	
   112	    }
   113	    else if(plist == "minervame1d" || plist == "minervame1D"){
   114	      return
   115	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
   116	                                         plist,
   117	                                         PlotUtils::FluxReweighter::gen2thin,
   118	                                         PlotUtils::FluxReweighter::g4numiv6,
   119	                                         n_flux_universes );
   120	
   121	    }
   122	    else if(plist == "minervame1e" || plist == "minervame1E"){
   123	      return
   124	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
   125	                                         plist,
   126	                                         PlotUtils::FluxReweighter::gen2thin,
   127	                                         PlotUtils::FluxReweighter::g4numiv6,
   128	                                         n_flux_universes );
   129	
   130	    }
   131	    else if(plist == "minervame1f" || plist == "minervame1F"){
   132	      return
   133	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
   134	                                         plist,
   135	                                         PlotUtils::FluxReweighter::gen2thin,
   136	                                         PlotUtils::FluxReweighter::g4numiv6,
   137	                                         n_flux_universes );
   138	
   139	    }
   140	    else if(plist == "minervame1g" || plist == "minervame1G"){
   141	      return
   142	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
   143	                                         plist,
   144	                                         PlotUtils::FluxReweighter::gen2thin,
   145	                                         PlotUtils::FluxReweighter::g4numiv6,
   146	                                         n_flux_universes );
   147	
   148	    }
   149	    else if(plist == "minervame1h" || plist == "minervame1H"){
   150	      return
   151	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
   152	                                         plist,
   153	                                         PlotUtils::FluxReweighter::gen2thin,
   154	                                         PlotUtils::FluxReweighter::g4numiv6,
   155	                                         n_flux_universes );
   156	
   157	    }
   158	    else if(plist == "minervame1l" || plist == "minervame1L"){
   159	      return
   160	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
   161	                                         plist,
   162	                                         PlotUtils::FluxReweighter::gen2thin,
   163	                                         PlotUtils::FluxReweighter::g4numiv6,
   164	                                         n_flux_universes );
   165	    }
   166	    else if(plist == "minervame1m" || plist == "minervame1M"){
   167	      return
   168	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
   169	                                         plist,
   170	                                         PlotUtils::FluxReweighter::gen2thin,
   171	                                         PlotUtils::FluxReweighter::g4numiv6,
   172	                                         n_flux_universes );
   173	    }
   174	    else if(plist == "minervame1n" || plist == "minervame1N"){
   175	      return
   176	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
   177	                                         plist,
   178	                                         PlotUtils::FluxReweighter::gen2thin,
   179	                                         PlotUtils::FluxReweighter::g4numiv6,
   180	                                         n_flux_universes );
   181	
   182	    }
   183	    else if(plist == "minervame1o" || plist == "minervame1O"){
   184	      return
   185	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
   186	                                         plist,
   187	                                         PlotUtils::FluxReweighter::gen2thin,
   188	                                         PlotUtils::FluxReweighter::g4numiv6,
   189	                                         n_flux_universes );
   190	    }
   191	    else if(plist == "minervame1p" || plist == "minervame1P"){
   192	      return
   193	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
   194	                                         plist,
   195	                                         PlotUtils::FluxReweighter::gen2thin,
   196	                                         PlotUtils::FluxReweighter::g4numiv6,
   197	                                         n_flux_universes );
   198	
   199	    }
   200	    else if (plist == "minervame1d1m1nweightedave") {
   201	      return
   202	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
   203	                                         plist,
   204	                                         PlotUtils::FluxReweighter::gen2thin,
   205	                                         PlotUtils::FluxReweighter::g4numiv6,
   206	                                         n_flux_universes );
   207	
   208	    }
   209	    else if(plist == "minervame5a" || plist == "minervame5A"){
   210	      return
   211	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
   212	                                         plist,
   213	                                         PlotUtils::FluxReweighter::gen2thin,
   214	                                         PlotUtils::FluxReweighter::g4numiv6,
   215	                                         n_flux_universes );
   216	
   217	    }
   218	    else if(plist == "minervame6a" || plist == "minervame6A"){
   219	      return
   220	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
   221	                                         plist,
   222	                                         PlotUtils::FluxReweighter::gen2thin,
   223	                                         PlotUtils::FluxReweighter::g4numiv6,
   224	                                         n_flux_universes );
   225	    }
   226	    else if(plist == "minervame6b" || plist == "minervame6B"){
   227	      return
   228	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
   229	                                         plist,
   230	                                         PlotUtils::FluxReweighter::gen2thin,
   231	                                         PlotUtils::FluxReweighter::g4numiv6,
   232	                                         n_flux_universes );
   233	    }
   234	    else if(plist == "minervame6c" || plist == "minervame6C"){
   235	      return
   236	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
   237	                                         plist,
   238	                                         PlotUtils::FluxReweighter::gen2thin,
   239	                                         PlotUtils::FluxReweighter::g4numiv6,
   240	                                         n_flux_universes );
   241	    }
   242	    else if(plist == "minervame6d" || plist == "minervame6D"){
   243	      return
   244	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
   245	                                         plist,
   246	                                         PlotUtils::FluxReweighter::gen2thin,
   247	                                         PlotUtils::FluxReweighter::g4numiv6,
   248	                                         n_flux_universes );
   249	    }
   250	    else if(plist == "minervame6e" || plist == "minervame6E"){
   251	      return
   252	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
   253	                                         plist,
   254	                                         PlotUtils::FluxReweighter::gen2thin,
   255	                                         PlotUtils::FluxReweighter::g4numiv6,
   256	                                         n_flux_universes );
   257	    }
   258	    else if(plist == "minervame6f" || plist == "minervame6F"){
   259	      return
   260	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
   261	                                         plist,
   262	                                         PlotUtils::FluxReweighter::gen2thin,
   263	                                         PlotUtils::FluxReweighter::g4numiv6,
   264	                                         n_flux_universes );
   265	    }
   266	    else if(plist == "minervame6g" || plist == "minervame6G"){
   267	      return
   268	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
   269	                                         plist,
   270	                                         PlotUtils::FluxReweighter::gen2thin,
   271	                                         PlotUtils::FluxReweighter::g4numiv6,
   272	                                         n_flux_universes );
   273	    }
   274	    else if(plist == "minervame6h" || plist == "minervame6H"){
   275	      return
   276	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
   277	                                         plist,
   278	                                         PlotUtils::FluxReweighter::gen2thin,
   279	                                         PlotUtils::FluxReweighter::g4numiv6,
   280	                                         n_flux_universes );
   281	    }
   282	    else if(plist == "minervame6i" || plist == "minervame6I"){
   283	      return
   284	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
   285	                                         plist,
   286	                                         PlotUtils::FluxReweighter::gen2thin,
   287	                                         PlotUtils::FluxReweighter::g4numiv6,
   288	                                         n_flux_universes );
   289	    }
   290	    else if(plist == "minervame6j" || plist == "minervame6J"){
   291	      return
   292	          new PlotUtils::FluxReweighter( nu_pdg, use_nuE_constraint,
   293	                                         plist,
   294	                                         PlotUtils::FluxReweighter::gen2thin,
   295	                                         PlotUtils::FluxReweighter::g4numiv6,
   296	                                         n_flux_universes );
   297	    }
   298	
   299	
   300	    else {
   301	      std::cerr << "ERROR flux_reweighter playlist string unrecognized "
   302	                << plist << std::endl;
   303	      std::exit(1);
   304	    }
   305	  }
   306	}
   307	
   308	namespace PlotUtils
   309	{
   310	  //============================================================================
   311	  FluxReweighter::FluxReweighter(int nuPDG,
   312	      bool applyNuEConstraint,
   313	      enum EPlaylist playlist,
   314	      enum EFluxVersion fluxVersion,
   315	      enum EG4NumiVersion g4NumiVersion,
   316	      int nUniverses/*= 200*/)
   317	  {
   318	    // cache the current directory
   319	    TDirectory* original_dir = gDirectory->CurrentDirectory();
   320	
   321	    // for the LE nUniverses can't be greater than 100
   322	    if (LeOrMe(playlist)==1&&nUniverses>100) {
   323	      nUniverses = 100;
   324	    }
   325	
   326	    // These member variables need to be set here because they're used downstream within the constructor
   327	    m_applyNuEConstraint = applyNuEConstraint;
   328	    m_nFluxUniverses = nUniverses;
   329	    m_fluxErrorName = "Flux";
   330	
   331	    m_fluxReweightNu    = GetFluxMnvH1D(abs(nuPDG),    playlist, fluxVersion, g4NumiVersion);
   332	    m_fluxReweightNubar = GetFluxMnvH1D(-1*abs(nuPDG), playlist, fluxVersion, g4NumiVersion);
   333	
   334	    d_Playlist = playlist;
   335	    if (applyNuEConstraint) {
   336	      std::cout << "Applying flux constraint to nu histogram" << std::endl;
   337	      m_fluxReweightNu = Constrainer().ConstrainHisto<MnvH1D, MnvVertErrorBand>( m_fluxReweightNu );
   338	      std::cout << "Applying flux constraint to nubar histogram" << std::endl;
   339	      m_fluxReweightNubar = Constrainer().ConstrainHisto<MnvH1D, MnvVertErrorBand>( m_fluxReweightNubar );
   340	    }
   341	
   342	    // Downstream methods require access to the original set of universe weights, so we will propagate an un-truncated
   343	    // copy of the flux histograms for local use, but not to be passed on to the user
   344	  //  m_fluxReweightNu_Ref = m_fluxReweightNu->Clone();
   345	  //  m_fluxReweightNubar_Ref = m_fluxReweightNubar->Clone();
   346	
   347	    if(nuPDG>0)m_fluxReweightNu_Ref = m_fluxReweightNu->Clone();
   348	    else{
   349	
   350	    m_fluxReweightNu_Ref = m_fluxReweightNubar->Clone();
   351	
   352	    }
   353	    if (nUniverses < 1000) {
   354	      TruncateNumberOfFluxUniverses( m_fluxReweightNu , nUniverses );
   355	      TruncateNumberOfFluxUniverses( m_fluxReweightNubar , nUniverses );
   356	    }
   357	
   358	    m_fluxGenNu    = GetFluxMnvH1D(abs(nuPDG),    playlist, fluxVersion, g4NumiVersion, true);
   359	    m_fluxGenNubar = GetFluxMnvH1D(-1*abs(nuPDG), playlist, fluxVersion, g4NumiVersion, true);
   360	    m_reweightMELowNuDataMC = GetMELowNuMnvH1D();
   361	
   362	    SetFluxSysMnvH1D(nuPDG,fluxVersion);
   363	
   364	    m_MELowNuDataMCRatioSpline = GetSpline(m_reweightMELowNuDataMC);
   365	
   366	    // return to the original directory
   367	    original_dir->cd();
   368	  }
   369	
   370	
   371	  //============================================================================
   372	  FluxReweighter::FluxReweighter(int nuPDG,
   373	      bool applyNuEConstraint,
   374	      std::string playlist_str,
   375	      enum EFluxVersion fluxVersion,
   376	      enum EG4NumiVersion g4NumiVersion,
   377	      int nUniverses/*= 200*/)
   378	  {
   379	    // cache the current directory
   380	    TDirectory* original_dir = gDirectory->CurrentDirectory();
   381	
   382	    // These member variables need to be set here because they're used
   383	    // downstream within the constructor
   384	    m_applyNuEConstraint = applyNuEConstraint;
   385	    m_nFluxUniverses = nUniverses;
   386	    m_fluxErrorName = "Flux";
   387	
   388	    FluxReweighter::EPlaylist playlist = GetPlaylistEnum(playlist_str);
   389	    d_Playlist = playlist;
   390	
   391	    // for the LE nUniverses can't be greater than 100
   392	    if (LeOrMe(playlist)==1&&nUniverses>100) {
   393	      nUniverses = 100;
   394	    }
   395	
   396	    m_fluxReweightNu    = GetFluxMnvH1D(abs(nuPDG),    playlist, fluxVersion, g4NumiVersion);
   397	    m_fluxReweightNubar = GetFluxMnvH1D(-1*abs(nuPDG), playlist, fluxVersion, g4NumiVersion);
   398	
   399	    if (applyNuEConstraint) {
   400	      //std::cout << "Applying flux constraint to nu histogram" << std::endl;
   401	      m_fluxReweightNu =
   402	          Constrainer().ConstrainHisto<MnvH1D, MnvVertErrorBand>( m_fluxReweightNu );
   403	      //std::cout << "Applying flux constraint to nubar histogram" << std::endl;
   404	      m_fluxReweightNubar =
   405	          Constrainer().ConstrainHisto<MnvH1D, MnvVertErrorBand>( m_fluxReweightNubar );
   406	    }
   407	
   408	    // Downstream methods require access to the original set of universe
   409	    // weights, so we will propagate an un-truncated copy of the flux
   410	    // histograms for local use, but not to be passed on to the user
   411	    //m_fluxReweightNu_Ref = m_fluxReweightNu->Clone();
   412	    //m_fluxReweightNubar_Ref = m_fluxReweightNubar->Clone();
   413	     if(nuPDG>0)m_fluxReweightNu_Ref = m_fluxReweightNu->Clone();
   414	    else{
   415	
   416	    m_fluxReweightNu_Ref = m_fluxReweightNubar->Clone();
   417	
   418	    }
   419	
   420	    if (nUniverses < 1000) {
   421	      TruncateNumberOfFluxUniverses( m_fluxReweightNu,    nUniverses );
   422	      TruncateNumberOfFluxUniverses( m_fluxReweightNubar, nUniverses );
   423	    }
   424	
   425	    m_fluxGenNu    = GetFluxMnvH1D(abs(nuPDG),    playlist, fluxVersion, g4NumiVersion, true);
   426	    m_fluxGenNubar = GetFluxMnvH1D(-1*abs(nuPDG), playlist, fluxVersion, g4NumiVersion, true);
   427	    m_reweightMELowNuDataMC = GetMELowNuMnvH1D();
   428	
   429	    SetFluxSysMnvH1D(nuPDG,fluxVersion);
   430	
   431	    m_MELowNuDataMCRatioSpline = GetSpline(m_reweightMELowNuDataMC);
   432	
   433	    // return to the original directory
   434	    original_dir->cd();
   435	  }
   436	
   437	
   438	  //============================================================================
   439	  FluxReweighter::FluxReweighter(MnvH1D* fluxGenNu,
   440	                                 MnvH1D* fluxGenNubar,
   441	                                 MnvH1D* fluxReweightNu,
   442	                                 MnvH1D* fluxReweightNubar,
   443	                                 TSpline3* MELowNuDataMCRatioSpline,
   444	                                 bool applyNuEConstraint)
   445	    : m_fluxGenNu(fluxGenNu),
   446	      m_fluxGenNubar(fluxGenNubar),
   447	      m_fluxReweightNu(fluxReweightNu),
   448	      m_fluxReweightNubar(fluxReweightNubar),
   449	      m_MELowNuDataMCRatioSpline(MELowNuDataMCRatioSpline)
   450	  {
   451	    // cache the current directory
   452	    TDirectory* original_dir = gDirectory->CurrentDirectory();
   453	
   454	    if (applyNuEConstraint) {
   455	      std::cout << "Applying flux constraint to nu histogram" << std::endl;
   456	      m_fluxReweightNu =
   457	          Constrainer().ConstrainHisto<MnvH1D, MnvVertErrorBand>( m_fluxReweightNu );
   458	      std::cout << "Applying flux constraint to nubar histogram" << std::endl;
   459	      m_fluxReweightNubar =
   460	          Constrainer().ConstrainHisto<MnvH1D, MnvVertErrorBand>( m_fluxReweightNubar );
   461	    }
   462	    m_applyNuEConstraint = applyNuEConstraint;
   463	    m_nFluxUniverses = 1000;
   464	    m_fluxErrorName = "Flux";
   465	
   466	    // return to the original directory
   467	    original_dir->cd();
   468	  }
   469	
   470	
   471	  //============================================================================
   472	  FluxReweighter::~FluxReweighter()
   473	  {
   474	    delete m_fluxGenNu;
   475	    delete m_fluxGenNubar;
   476	    delete m_fluxReweightNu;
   477	    delete m_fluxReweightNubar;
   478	    delete m_fluxReweightNu_Ref;
   479	    //delete m_fluxReweightNubar_Ref;
   480	    delete m_MELowNuDataMCRatioSpline;
   481	    delete m_reweightMELowNuDataMC;
   482	  }
   483	
   484	
   485	  //============================================================================
   486	  MnvHistoConstrainer& FluxReweighter::Constrainer()
   487	  {
   488	    static MnvHistoConstrainer* _constrainer=0;
   489	    if (!_constrainer) {
   490	      _constrainer=new MnvHistoConstrainer;
   491	
   492	      const char* mparam=gSystem->Getenv("MPARAMFILES");
   493	      if (!mparam || !strlen(mparam)) {
   494	        std::cout << "$MPARAMFILES is not set. Can't find universe weights for "
   495	                  << "nu+e constraint" << std::endl;
   496	        std::exit(1);
   497	      }
   498	      std::string filename(mparam);
   499	      int iplaylist = LeOrMe(d_Playlist);
   500	      // Timebeing 1 = LE; 2 = ME (ALL Playlist)
   501	      if (iplaylist == 1) {
   502	        filename+="/FluxConstraints/nu+e_eroica.txt";
   503	      }
   504	      //Using the combined fhc+rhc+imd constraint
   505	      else if (iplaylist == 2 or iplaylist==3) {
   506		filename+="/FluxConstraints/sorted_NuEConstraint_FHC_RHC_IMD.txt";
   507	      }
   508	      
   509	      //This is the nu+e method with fhc measurement
   510	      /*      
   511	      else if (iplaylist == 2 || iplaylist==3) {
   512		filename+="/FluxConstraints/nu+e_ME_spectrum.txt";
   513	      }
   514	      */
   515	      
   516	      //This is the IMD method
   517	      /*
   518	      else if (iplaylist == 2 or iplaylist==3) {
   519		std::cout << "I am running with the IMD constraint" << std::endl;
   520	      	filename+="/FluxConstraints/IMDweights_unordered.txt";
   521	      }
   522	      */
   523	      //This is the nu+e method with rhc measurement
   524	      /*
   525	      else if (iplaylist ==3){
   526	        filename +="/FluxConstraints/sorted_nu+e_RHC_Final.txt";
   527	
   528	      }
   529	      */
   530	      _constrainer->LoadConstraint( "nu+e", filename );
   531	
   532	      _constrainer->SetSpectatorCorrectionStrategy("Flux_BeamFocus", MnvHistoConstrainer::PRESERVE_FRACTIONAL_ERR);
   533	      _constrainer->SetSpectatorCorrectionStrategy("ppfx1_Total", MnvHistoConstrainer::PRESERVE_FRACTIONAL_ERR);
   534	    }
   535	    return *_constrainer;
   536	  }
   537	
   538	
   539	  //======================================================================
   540	  MnvH1D* FluxReweighter::GetMnvH1D(TString filename, TString histname)
   541	  {
   542	    TFile f(filename);
   543	    if (f.IsZombie()) {
   544	      std::cout << "Can't open flux file with name " << filename << std::endl;
   545	      std::exit(1);
   546	    }
   547	    MnvH1D* ret=(MnvH1D*)f.Get(histname);
   548	    if (!ret) {
   549	      std::cout << "Can't find flux histogram with name " << histname << " in file " << filename << std::endl;
   550	      std::exit(1);
   551	    }
   552	    ret->SetDirectory(0);
   553	    return ret;
   554	  }
   555	
   556	
   557	  //============================================================================
   558	  MnvH1D* FluxReweighter::GetTargetFluxMnvH1D(int nuPDG,
   559	                                              std::string tar_mat,
   560	                                              std::string project_dir)
   561	  {
   562	
   563	    if( nuPDG != 14 ) {
   564	      std::cout << "FRW: Target fluxes have been generated for muon neutrinos only" <<std::endl;
   565	      std::exit(1);
   566	    }
   567	
   568	    if( !m_applyNuEConstraint ) {
   569	      std::cout << "FRW: Target fluxes have been generated for nu-e constraints only" <<std::endl;
   570	      std::exit(1);
   571	    }
   572	
   573	    const char* plotutils=gSystem->Getenv("PLOTUTILSROOT");
   574	    if (!plotutils || !strlen(plotutils)) {
   575	      std::cout << "$PLOTUTILSROOT is not set. Can't find flux histograms" << std::endl;
   576	      std::exit(1);
   577	    }
   578	
   579	    //NOTE: Target fluxes are made with gen2thin and g4numiv6 - 9/7/2021
   580	
   581	    TString tracker_filename = TString::Format("%s/data/flux_daisy/%s/flux_with_errors/flux_tracker.root",
   582	                                                plotutils,
   583	                                                project_dir.c_str(),
   584	                                                tar_mat.c_str());
   585	
   586	    TString tarfilename = TString::Format("%s/data/flux_daisy/%s/flux_with_errors/flux_%s.root",
   587	                                           plotutils,
   588	                                           project_dir.c_str(),
   589	                                           tar_mat.c_str());
   590	
   591	    TString histName = TString::Format("flux");
   592	
   593	    MnvH1D* tracker_flux = GetMnvH1D(tracker_filename, histName);
   594	    MnvH1D* tar_flux     = GetMnvH1D(tarfilename, histName);
   595	
   596	    //Will use ratio of target/tracker to supply a weight to make the correct flux universes
   597	
   598	    MnvH1D* h_flux       = (MnvH1D*)m_fluxReweightNu->Clone(Form("flux_%s",tar_mat.c_str()));
   599	    MnvH1D* ratio_flux   = (MnvH1D*)m_fluxReweightNu->Clone(Form("tmp_flux_ratio_%s",tar_mat.c_str())); 
   600	    ratio_flux->ClearAllErrorBands();
   601	    ratio_flux->Reset();
   602	
   603	    //Create a ratio of targets/tracker
   604	    for( int iBin = 0; iBin < ratio_flux->GetNbinsX()+2; ++iBin )
   605	    {
   606	      double binCenter = ratio_flux->GetBinCenter(iBin);
   607	
   608	      int iBinTracker  = tracker_flux->FindBin(binCenter);
   609	      int iBinTarget   = tar_flux->FindBin(binCenter);
   610	
   611	      double content_tracker = tracker_flux->GetBinContent(iBinTracker);
   612	      double content_target  = tar_flux->GetBinContent(iBinTarget);
   613	
   614	      ratio_flux->SetBinContent( iBin, content_tracker > 0 ? content_target/content_tracker : 1.0 );
   615	      ratio_flux->SetBinError(   iBin, 0.0 );
   616	    }
   617	
   618	    ratio_flux->AddMissingErrorBandsAndFillWithCV( *h_flux );
   619	    h_flux->Multiply( h_flux, ratio_flux );
   620	
   621	    //std::vector< std::string > vert_error_names = h_flux->GetVertErrorBandNames();
   622	    //for( auto &name : vert_error_names ) {
   623	    //  if( strcmp( name.c_str(), "Flux" ) != 0 ) h_flux->PopVertErrorBand(name);
   624	    //}
   625	
   626	    //std::vector< std::string > lat_error_names  = h_flux->GetLatErrorBandNames();
   627	    //for( auto &name : lat_error_names ) {
   628	    //  if( strcmp( name.c_str(), "Flux" ) != 0 ) h_flux->PopLatErrorBand(name);
   629	    //}
   630	
   631	    return h_flux;
   632	
   633	  }
   634	
   635	  //============================================================================
   636	  MnvH1D* FluxReweighter::GetDaisyParamMnvH1D(int nuPDG,
   637	                                              std::string tar_mat,
   638	                                              std::string project_dir)
   639	  {
   640	
   641	    if( nuPDG != 14 ) {
   642	      std::cout << "FRW: Daisy reweights have been generated for muon neutrinos only" <<std::endl;
   643	      std::exit(1);
   644	    }
   645	
   646	    if( !m_applyNuEConstraint ) {
   647	      std::cout << "FRW: Daisy reweights have been generated for nu-e constraints only" <<std::endl;
   648	      std::exit(1);
   649	    }
   650	
   651	    const char* plotutils=gSystem->Getenv("PLOTUTILSROOT");
   652	    if (!plotutils || !strlen(plotutils)) {
   653	      std::cout << "$PLOTUTILSROOT is not set. Can't find daisy reweights" << std::endl;
   654	      std::exit(1);
   655	    }
   656	
   657	    MnvH1D* h_param;
   658	
   659	    if( strcmp( tar_mat.c_str(), "tracker" ) == 0 ) {
   660	      h_param = new MnvH1D("tracker_param_hist", "tracker_param_hist;Flux Bin;Weight", 12, 0., 12.);
   661	      for( int iBin = 1; iBin <= 12; ++iBin ) {
   662	        h_param->SetBinContent(iBin, 1);
   663	        h_param->SetBinError(iBin, 0);
   664	      }
   665	    }
   666	    else{
   667	      TString filename = TString::Format("%s/data/flux_daisy/%s/out_%s_000100.root",
   668	                                           plotutils,
   669	                                           project_dir.c_str(),
   670	                                           tar_mat.c_str());
   671	
   672	      TString histName = TString::Format("param_hist");
   673	
   674	      //std::cout<<"FRW: Getting daisy reweight parameters"<<std::endl;
   675	      h_param = GetMnvH1D(filename, histName);
   676	    }
   677	    return h_param;    
   678	
   679	  }
   680	  //============================================================================
   681	  MnvH1D* FluxReweighter::GetFluxMnvH1D(int nuPDG,
   682	      enum EPlaylist playlist,
   683	      enum EFluxVersion fluxVersion,
   684	      enum EG4NumiVersion g4NumiVersion,
   685	      bool useGen  /*=false*/)
   686	  {
   687	    const char* plotutils=gSystem->Getenv("PLOTUTILSROOT");
   688	    if (!plotutils || !strlen(plotutils)) {
   689	      std::cout << "$PLOTUTILSROOT is not set. Can't find flux histograms" << std::endl;
   690	      std::exit(1);
   691	    }
   692	
   693	    if(m_applyNuEConstraint&&IsCustomFlux(fluxVersion)){
   694	      std::cout << "Application of the nu-e constraint is incompapitable with using a non-PPFX flux!! I'm exiting." << std::endl;
   695	      std::exit(1);
   696	    }
   697	
   698	    const char* constraintString;
   699	    int iplaylist = LeOrMe(playlist);
   700	    // Timebeing 1 = LE; 2 = ME (ALL Playlist)
   701	    if (iplaylist==1) {
   702	      constraintString =  "";
   703	    }
   704	    //This is the nu+e
   705	    if(iplaylist==2 or iplaylist==3)constraintString = m_applyNuEConstraint ? "_rearrangedUniverses" : "";
   706	    //This is the IMD method
   707	    //    if(iplaylist==2 or iplaylist==3)constraintString = m_applyNuEConstraint ? "" : "";
   708	
   709	    TString filename;
   710	    const char* histName;
   711	
   712	    // If using lowNu or highNu flux, use different prescription to fetch it
   713	    // For the reweighted flux
   714	    if(IsCustomFlux(fluxVersion)&&!useGen){
   715	      histName = fluxForSystematicsHistName(fluxVersion);
   716	      filename = TString::Format("%s/data/flux/sys/%s.root",
   717	            plotutils,
   718	            histName);
   719	    }
   720	    // For the generated flux
   721	    else if(IsCustomFlux(fluxVersion)&&useGen){
   722	      histName = "genFlux_coarseBinning_MnvH1D";
   723	      filename = TString::Format("%s/data/flux/sys/genFlux_coarseBinning_MnvH1D.root",
   724	            plotutils);
   725	    }
   726	    // Default prescription for assembling file and hist names
   727	    else{
   728	      const char* fluxString;
   729	      fluxString = useGen ? g4NumiVersionString(g4NumiVersion) : fluxVersionString(fluxVersion);
   730	
   731	      filename = TString::Format("%s/data/flux/flux-%s-pdg%d-%s%s.root",
   732	            plotutils,
   733	            fluxString,
   734	            nuPDG,
   735	            playlistString(playlist),
   736	            constraintString);
   737	
   738	      histName = useGen ? "flux_E_unweighted" : "flux_E_cvweighted";
   739	    }
   740	
   741	    std::cout << "FRW: this is the flux file I'm using: " << filename << std::endl;
   742	    return GetMnvH1D(filename, histName);
   743	  }
   744	  //============================================================================
   745	
   746	  MnvH1D* FluxReweighter::GetMELowNuMnvH1D()
   747	  {
   748	    const char* plotutils=gSystem->Getenv("PLOTUTILSROOT");
   749	    if (!plotutils || !strlen(plotutils)) {
   750	      std::cout << "$PLOTUTILSROOT is not set. Can't find flux histograms" << std::endl;
   751	      std::exit(1);
   752	    }
   753	
   754	    TString filename(TString::Format("%s/data/lowNuReweight/lowNuReweight.root",
   755	          plotutils));
   756	    return GetMnvH1D(filename, "ratio");
   757	  }
   758	
   759	
   760	  //============================================================================
   761	  TSpline3* FluxReweighter::GetSpline(MnvH1D *h)
   762	  {
   763	    const char* plotutils=gSystem->Getenv("PLOTUTILSROOT");
   764	    if (!plotutils || !strlen(plotutils)) {
   765	      std::cout << "$PLOTUTILSROOT is not set. Can't find flux histograms" << std::endl;
   766	      std::exit(1);
   767	    }
   768	
   769	    TSpline3 *spl = new TSpline3(h);
   770	    return spl;
   771	  }
   772	
   773	
   774	  //============================================================================
   775	  double FluxReweighter::GetFluxCVWeight( double Enu, int nuPDG )
   776	  {
   777	    MnvH1D* genFlux = nuPDG > 0 ? m_fluxGenNu      : m_fluxGenNubar;
   778	    MnvH1D* newFlux = nuPDG > 0 ? m_fluxReweightNu : m_fluxReweightNubar;
   779	
   780	    double num = newFlux->Interpolate( Enu );
   781	    double dem = genFlux->Interpolate( Enu );
   782	    if(Enu>75.){//Condition to avoid the large slope at large Enu which causes crazy weights. Slope in that region is 10^-22 or so
   783	      num = newFlux->GetBinContent(newFlux->FindBin(Enu));
   784	      dem = genFlux->GetBinContent(genFlux->FindBin(Enu));
   785	    }
   786	    if (num ==0 ||dem ==0) {
   787	      return 1;
   788	    }
   789	    return  num/dem;
   790	  }
   791	
   792	
   793	  //============================================================================
   794	  // Suggested alternate name: FRW::GetFluxSystematicUniverseWeight
   795	  double FluxReweighter::GetSysUniFluxWeightCorrection( double Enu,
   796	                                                        int nuPDG,
   797	                                                        std::string sys_name,
   798	                                                        int universe)
   799	  // This method returns the multiplicative factor that should modify the flux weight
   800	  // in the evaluation of some systematic universes. Currently the use cases are
   801	  // the evaluation in FHC of the muon-momentum-shifted universes for most users and
   802	  // the high-nu flux analysis
   803	  // ----------
   804	  // POSSIBLY USEFUL TO FUTURE ANALYSTS: This method assumes the user
   805	  // uses the same names for their systematic universes as the available
   806	  // fluxes. To accomodate a different naming scheme, the user would have
   807	  // to add a method that maps user names onto the "standard" naming
   808	  // scheme. The best idea I have for how that would work is that FRW
   809	  // would own a map, and the user would interactively add (or overwrite)
   810	  // entries in that map to reflect their naming scheme. RDF 2020-01-10
   811	  // ----------
   812	  {
   813	    // FluxCorrection not valid for nue
   814	    if (nuPDG == -12 ) return 1;
   815	    if (nuPDG == 12 ) return 1;
   816	
   817	    //We also don't want the wrong sign fluxes to pick this correction... -David L. putting in Amit's changes from CVS commit 1.106-8
   818	    int iPlaylist = LeOrMe(d_Playlist);
   819	    if (iPlaylist==2 && nuPDG==-14) return 1;
   820	    if (iPlaylist==3 && nuPDG==14) return 1;
   821	
   822	    // FluxCorrection not valid for RHC numu (yet?) It is now!
   823	    //if (nuPDG == -14 ) return 1; Commented out now that RHC is valid. -David L. putting in Amit's changes from CVS commit 1.106-8
   824	    // Correction for Amit's Emu fluxes not useful above 15 GeV
   825	    if (sys_name == "Muon_Energy" && Enu > 15) return 1;
   826	    if (sys_name == "Muon_Energy_MINOS" && Enu > 15) return 1;
   827	
   828	    TH1D* cvFlux = m_fluxSystematicsMnvH1D;
   829	
   830	    TH1D* sysFlux = (TH1D*)m_fluxSystematicsMnvH1D->GetVertErrorBand(sys_name.c_str())->GetHist(universe);
   831	
   832	    /* Commented out now that RHC is valid. Replaced by the above lines. -David L. putting in Amit's changes from CVS commit 1.106-8
   833	    TH1D* cvFlux = nuPDG > 0 ?
   834	      m_fluxSystematicsMnvH1D :
   835	      NULL; // We may have a RHC case in the future
   836	
   837	    TH1D* sysFlux = nuPDG > 0 ?
   838	        (TH1D*)m_fluxSystematicsMnvH1D->GetVertErrorBand(sys_name.c_str())->GetHist(universe) :
   839	        NULL; // We may have a RHC case in the future
   840	    */
   841	
   842	    double num = sysFlux->Interpolate( Enu );
   843	    double dem = cvFlux->Interpolate( Enu );
   844	
   845	    if (num == 0 || dem == 0) return 1;
   846	
   847	    return num/dem;
   848	  }
   849	
   850	
   851	  //======================================================================
   852	  void FluxReweighter::SetFluxSysMnvH1D( int nuPDG, enum EFluxVersion fluxVersion)
   853	  {
   854	    const char* plotutils=gSystem->Getenv("PLOTUTILSROOT");
   855	    bool isNu = nuPDG>0?true:false; //Kept around in Amit CVS commit 1.108 for correlated muon fluxes. -David L.
   856	    const char* fluxName = fluxForSystematicsHistName(fluxVersion);
   857	
   858	    //if(nuPDG>0){ Commented out so that RHC correlations in fact grab the necessary file/histo. -David L.
   859	    //std::cout << "Creating alternate sysmap using the " << fluxName << " flux." << std::endl;
   860	    TFile myfile(TString::Format("%s/data/flux/sys/%s.root",plotutils,fluxName));
   861	    m_fluxSystematicsMnvH1D = (MnvH1D*)myfile.Get(TString::Format("%s",fluxName));
   862	    // assert will provide useful debug info only when the code is compiled in debug mode
   863	    assert(m_fluxSystematicsMnvH1D != NULL && "Failed to find a histogram of that name in FluxReweighter!  Maybe its name changed?");
   864	    m_fluxSystematicsMnvH1D->SetDirectory(0);
   865	    //} Commented out so that RHC correlations in fact grab the necessary file/histo. -David L.
   866	
   867	  }
   868	
   869	
   870	  //============================================================================
   871	  double FluxReweighter::GetMELowNuFluxWeight( double Enu )
   872	  {
   873	    return m_MELowNuDataMCRatioSpline->Eval(Enu);
   874	  }
   875	
   876	
   877	  //============================================================================
   878	  MnvH1D* FluxReweighter::GetRebinnedFluxGenerated(int nuPDG,
   879	                                                   MnvH1D* template_hist)
   880	  {
   881	    MnvH1D* h_flux = this->GetFluxGenerated(nuPDG);
   882	        //h_flux->SaveAs("fluxchecker_wowiggle.root");
   883	
   884	    MnvH1D* h_flux_rebinned =
   885	        (MnvH1D*)template_hist->Clone("generatedflux_rebinned");
   886	    h_flux_rebinned->ClearAllErrorBands();
   887	    h_flux_rebinned->Reset();
   888	
   889	    TH1D* tmp_flux_cv     =
   890	        new TH1D(h_flux->GetCVHistoWithStatError());
   891	    TH1D* tmp_template_cv =
   892	        new TH1D(h_flux_rebinned->GetCVHistoWithStatError());
   893	
   894	    FluxReweighter::RebinFluxHist(tmp_flux_cv,tmp_template_cv);
   895	
   896	    //CV first
   897	    for(int i=0;i<h_flux_rebinned->GetNbinsX()+2;i++)
   898	      h_flux_rebinned->SetBinContent(i,tmp_template_cv->GetBinContent(i));
   899	
   900	    //clean my mess
   901	    delete tmp_flux_cv;
   902	    delete tmp_template_cv;
   903	
   904	    //Now Flux Universes // DON'T Assume Flux is the only error
   905	    std::vector<std::string> vertNames = h_flux->GetVertErrorBandNames();
   906	    for(unsigned int k=0; k<vertNames.size(); ++k ) {
   907	      MnvVertErrorBand *errBand = h_flux->GetVertErrorBand( vertNames[k] );
   908	      const int universes = errBand->GetNHists();
   909	      std::vector<TH1D*> vert_hists;
   910	      for(int u=0;u<universes;++u) {
   911	        TH1D* tmp_flux = new TH1D(*errBand->GetHist( u ));
   912	        TH1D* tmp_template = new TH1D(h_flux_rebinned->GetCVHistoWithStatError());
   913	        tmp_template->SetName(Form("Flux_rebinned_universe_%d",u));
   914	        RebinFluxHist(tmp_flux,tmp_template);
   915	        vert_hists.push_back(tmp_template);
   916	      }
   917	      h_flux_rebinned->AddVertErrorBand( vertNames[k],vert_hists);
   918	      //clean my mess
   919	      for(std::vector<TH1D*>::iterator itHist = vert_hists.begin(); itHist != vert_hists.end(); ++itHist)
   920	        delete *itHist;
   921	    }
   922	    //AddMissingError with CV
   923	    h_flux_rebinned->AddMissingErrorBandsAndFillWithCV(*template_hist);
   924	    //h_flux_rebinned->SaveAs("Enu_Flux_nukecc.root");
   925	
   926	    return h_flux_rebinned;
   927	  }
   928	
   929	
   930	  //============================================================================
   931	  MnvH1D* FluxReweighter::GetRebinnedFluxReweighted(int nuPDG,
   932	                                                    MnvH1D* template_hist)
   933	  {
   934	    MnvH1D* h_flux = this->GetFluxReweighted(nuPDG);
   935	    h_flux->SaveAs("fluxchecker_wowiggle.root");
   936	
   937	    MnvH1D* h_flux_rebinned =
   938	        (MnvH1D*)template_hist->Clone("reweightedflux_rebinned");
   939	    h_flux_rebinned->ClearAllErrorBands();
   940	    h_flux_rebinned->Reset();
   941	
   942	    TH1D* tmp_flux_cv     =
   943	        new TH1D(h_flux->GetCVHistoWithStatError());
   944	    TH1D* tmp_template_cv =
   945	        new TH1D(h_flux_rebinned->GetCVHistoWithStatError());
   946	
   947	    FluxReweighter::RebinFluxHist(tmp_flux_cv,tmp_template_cv);
   948	
   949	    //CV first
   950	    for(int i=0;i<h_flux_rebinned->GetNbinsX()+2;i++)
   951	      h_flux_rebinned->SetBinContent(i,tmp_template_cv->GetBinContent(i));
   952	
   953	    //clean my mess
   954	    delete tmp_flux_cv;
   955	    delete tmp_template_cv;
   956	
   957	    //Now Flux Universes // DON'T Assume Flux is the only error
   958	    std::vector<std::string> vertNames = h_flux->GetVertErrorBandNames();
   959	    for(unsigned int k=0; k<vertNames.size(); ++k ) {
   960	      MnvVertErrorBand *errBand = h_flux->GetVertErrorBand( vertNames[k] );
   961	      const int universes = errBand->GetNHists();
   962	      std::vector<TH1D*> vert_hists;
   963	      for(int u=0;u<universes;++u) {
   964	        TH1D* tmp_flux = new TH1D(*errBand->GetHist( u ));
   965	        TH1D* tmp_template = new TH1D(h_flux_rebinned->GetCVHistoWithStatError());
   966	        tmp_template->SetName(Form("Flux_rebinned_universe_%d",u));
   967	        RebinFluxHist(tmp_flux,tmp_template);
   968	        vert_hists.push_back(tmp_template);
   969	      }
   970	      h_flux_rebinned->AddVertErrorBand( vertNames[k],vert_hists);
   971	      //clean my mess
   972	      for(std::vector<TH1D*>::iterator itHist = vert_hists.begin();
   973	          itHist != vert_hists.end(); ++itHist)
   974	        delete *itHist;
   975	    }
   976	    //AddMissingError with CV
   977	    h_flux_rebinned->AddMissingErrorBandsAndFillWithCV(*template_hist);
   978	    //h_flux_rebinned->SaveAs("Enu_Flux_nukecc.root");
   979	
   980	    // This method will fill the constraint weights in the Flux error band if appropriate
   981	    CheckAndFixFluxErrorBand( h_flux_rebinned );
   982	
   983	    return h_flux_rebinned;
   984	  }
   985	
   986	
   987	  //============================================================================
   988	  MnvH1D* FluxReweighter::GetRebinnedFluxReweighted_FromInputFlux(MnvH1D* input_flux,
   989	                                                                  MnvH1D* template_hist)
   990	  {
   991	    MnvH1D* h_flux = (MnvH1D*)input_flux->Clone("input_flux"); //this->GetFluxReweighted(nuPDG);
   992	
   993	    MnvH1D* h_flux_rebinned =
   994	        (MnvH1D*)template_hist->Clone("reweightedflux_rebinned");
   995	    h_flux_rebinned->ClearAllErrorBands();
   996	    h_flux_rebinned->Reset();
   997	
   998	    TH1D* tmp_flux_cv     =
   999	        new TH1D(h_flux->GetCVHistoWithStatError());
  1000	    TH1D* tmp_template_cv =
  1001	        new TH1D(h_flux_rebinned->GetCVHistoWithStatError());
  1002	
  1003	    FluxReweighter::RebinFluxHist(tmp_flux_cv,tmp_template_cv);
  1004	
  1005	    //CV first
  1006	    for(int i=0;i<h_flux_rebinned->GetNbinsX()+2;i++)
  1007	      h_flux_rebinned->SetBinContent(i,tmp_template_cv->GetBinContent(i));
  1008	
  1009	    //clean my mess
  1010	    delete tmp_flux_cv;
  1011	    delete tmp_template_cv;
  1012	
  1013	    h_flux_rebinned->AddMissingErrorBandsAndFillWithCV(*template_hist);
  1014	
  1015	    //if (m_applyNuEConstraint) {
  1016	    //  std::cout << "Applying flux constraint to rebinned histogram" << std::endl;
  1017	    //  h_flux_rebinned = Constrainer().ConstrainHisto<MnvH1D, MnvVertErrorBand>( h_flux_rebinned );
  1018	    //}
  1019	
  1020	    return h_flux_rebinned;
  1021	  }
  1022	
  1023	
  1024	  //============================================================================
  1025	  void FluxReweighter::RebinFluxHist(TH1D* h_flux, TH1D*&h_rebinned_flux)
  1026	  {
  1027	    //strategy is to recale orig by bin width (undo bin width normalization)
  1028	    //then combine bins and then rescale by binwidth again
  1029	    TH1D* scaler = (TH1D*)h_flux->Clone("fluxscaler");
  1030	    TH1D* flux_cv = (TH1D*)h_flux->Clone("fluxcvtomod");
  1031	    for(int i=1;i<scaler->GetNbinsX();i++)
  1032	      scaler->SetBinContent(i,scaler->GetBinWidth(i));
  1033	    flux_cv->Multiply(scaler);//undid bin width normalization
  1034	    std::vector<double>rebinned_flux_bin_edges;
  1035	    for(int i=1;i<h_rebinned_flux->GetNbinsX()+2;i++) { //need low edge of overflow (high edge of last bin)
  1036	      rebinned_flux_bin_edges.push_back(h_rebinned_flux->GetBinLowEdge(i));
  1037	    }
  1038	    for(unsigned int i=0;i<rebinned_flux_bin_edges.size();i++) { //need low edge of overflow (high edge of last bin)
  1039	      //std::cout<<i<<"  "<<h_rebinned_flux->GetBinLowEdge(i)<<std::endl;
  1040	      //rebinned_flux_bin_edges.push_back(h_rebinned_flux->GetBinLowEdge(i));
  1041	      //std::cout<<i<<"  "<<rebinned_flux_bin_edges[i]<<std::endl;
  1042	    }
  1043	    h_rebinned_flux = (TH1D*)flux_cv->Rebin(rebinned_flux_bin_edges.size()-1,
  1044	                                            "Fluxrebinned",
  1045	                                            &rebinned_flux_bin_edges[0]);
  1046	    h_rebinned_flux->Scale(1.0,"width");//And redo bin width norm
  1047	  }
  1048	
  1049	  //============================================================================
  1050	  template<class MnvHistoType>
  1051	  MnvHistoType* FluxReweighter::GetIntegratedFluxReweighted(int nuPDG,
  1052	                                                      MnvHistoType* template_hist,
  1053	                                                      double min_energy,
  1054	                                                      double max_energy,
  1055	                                                      bool use_muon_correlations)
  1056	  {
  1057	
  1058	    // This is the hist that will be retured to the user. Start from a clean slate
  1059	    MnvHistoType* h_flux_integrated = (MnvHistoType*)template_hist->Clone("reweightedflux_integrated");
  1060	    h_flux_integrated->ClearAllErrorBands();
  1061	    h_flux_integrated->Reset();
  1062	
  1063	    // The default flux prescription is PPFX plus correlated fluxes for
  1064	    // "Muon_Energy" or "Muon_Energy_MINOS" systematic universes
  1065	    if(m_useStandardFlux){
  1066	
  1067	      MnvH1D* h_flux_ppfx = this->GetFluxReweighted(nuPDG);
  1068	
  1069	      //Get bins to integrate over
  1070	      int ppfx_b_min = h_flux_ppfx->FindBin( min_energy );
  1071	      int ppfx_b_max = h_flux_ppfx->FindBin( max_energy );
  1072	      //get integral
  1073	      double int_flux_cv = h_flux_ppfx->Integral( ppfx_b_min, ppfx_b_max , "width" );
  1074	      // The correlated muon fluxes only provide predictions below 15 GeV, which makes correcting
  1075	      // the CV PPFX integrate flux a little more complicated
  1076	      int ppfx_b_15GeV = h_flux_ppfx->FindBin( 15. );
  1077	      double int_flux_cv_below15GeV;
  1078	      double int_flux_cv_above15GeV;
  1079	      if(min_energy>15.0){int_flux_cv_below15GeV = 0.;}
  1080	      else{int_flux_cv_below15GeV = h_flux_ppfx->Integral( ppfx_b_min, ppfx_b_15GeV, "width" );}
  1081	      if(max_energy<=15.0){int_flux_cv_above15GeV = 0.;}
  1082	      else{int_flux_cv_above15GeV = h_flux_ppfx->Integral( ppfx_b_15GeV+1, ppfx_b_max , "width" );}
  1083	      //CV first
  1084	      for(int i=0;i<h_flux_integrated->GetSize();i++)
  1085	        h_flux_integrated->SetBinContent(i,int_flux_cv);
  1086	
  1087	      // Integrate flux in every "Flux" systematic universe
  1088	      // To use a different PPFX error band, modify FRW initialization
  1089	      MnvVertErrorBand *errBand = h_flux_ppfx->GetVertErrorBand(m_fluxErrorName);
  1090	      const int universes = errBand->GetNHists();
  1091	      auto flux_sys_hists = GetVector(h_flux_integrated);
  1092	      for(int u=0;u<universes;++u) {
  1093	        TH1D* tmp_flux = new TH1D(*errBand->GetHist( u ));
  1094	        auto tmp_template = h_flux_integrated->GetCVHistoWithStatError();
  1095	        tmp_template.SetName(Form("Flux_integrated_universe_%d",u));
  1096	        double flux_uni = tmp_flux->Integral(ppfx_b_min,ppfx_b_max,"width");
  1097	        for(int i=0;i<h_flux_integrated->GetSize();i++)
  1098	          tmp_template.SetBinContent(i,flux_uni);
  1099	        flux_sys_hists.push_back(NewHist(tmp_template));
  1100	      }
  1101	      // Push the constructed error band into the return hist
  1102	      h_flux_integrated->AddVertErrorBand(m_fluxErrorName,flux_sys_hists);
  1103	
  1104	      // Integrate flux in special correlated flux universes. This is a correction on
  1105	      // the CV integrated flux calculated using separately produced systematic and CV
  1106	      // fluxes. This matches the implementation of FRW::GetSysUniFluxWeightCorrection
  1107	      if(use_muon_correlations){
  1108	
  1109	        // The correlated flux is constructed relative to a different CV
  1110	        TH1D* tmp_flux_special_cv = m_fluxSystematicsMnvH1D;
  1111	        //Get bins to integrate over
  1112	        int special_b_min = tmp_flux_special_cv->FindBin( min_energy );
  1113	        int special_b_max = tmp_flux_special_cv->FindBin( max_energy );
  1114	        //get integral
  1115	        double int_flux_special_cv = tmp_flux_special_cv->Integral(special_b_min,special_b_max,"width");
  1116	
  1117	        // Don't assume which convention the analyzer is using
  1118	        std::vector<std::string> errorBandsToLoop;
  1119	        if(template_hist->HasErrorBand("Muon_Energy")){errorBandsToLoop.push_back("Muon_Energy");}
  1120	        if(template_hist->HasErrorBand("Muon_Energy_MINOS")){errorBandsToLoop.push_back("Muon_Energy_MINOS");}
  1121	
  1122	        for(unsigned int k=0; k<errorBandsToLoop.size(); ++k ) {
  1123	          auto correlated_flux_hists = GetVector(h_flux_integrated);
  1124	          MnvVertErrorBand *errBand = m_fluxSystematicsMnvH1D->GetVertErrorBand( errorBandsToLoop[k] );
  1125	          for(int u=0;u<2;++u) { // There are two systematic variations corresponding to +/- 1 sigma
  1126	            // Fetch correlated flux from separate container
  1127	            TH1D* tmp_flux_special_sys = (TH1D*)errBand->GetHist(u);
  1128	            auto tmp_template = h_flux_integrated->GetCVHistoWithStatError();
  1129	            std::string tempString = Form("Flux_integrated_%s_universe_%d",errorBandsToLoop[k].c_str(),u);
  1130	            tmp_template.SetName(tempString.c_str());
  1131	            double int_flux_special_sys = tmp_flux_special_sys->Integral(special_b_min,special_b_max,"width");
  1132	            for(int i=0;i<h_flux_integrated->GetSize();i++)
  1133	              tmp_template.SetBinContent(i,(int_flux_special_sys/int_flux_special_cv)*int_flux_cv_below15GeV+int_flux_cv_above15GeV);
  1134	            correlated_flux_hists.push_back(NewHist(tmp_template));
  1135	          }
  1136	          // Push the constructed error band into the return hist.
  1137	          // Figure out if the analyzer is using a LatErrorBand or VertErrorBand :/
  1138	          if(template_hist->HasLatErrorBand(errorBandsToLoop[k])){
  1139	            h_flux_integrated->AddLatErrorBand(errorBandsToLoop[k],correlated_flux_hists);
  1140	          }
  1141	          else{
  1142	            h_flux_integrated->AddVertErrorBand(errorBandsToLoop[k],correlated_flux_hists);
  1143	          }
  1144	          // When MnvLatErrorBand goes away, replace the above (7) lines with the below line
  1145	          //h_flux_integrated->AddVertErrorBand(errorBandsToLoop[k],correlated_flux_hists);
  1146	        }
  1147	
  1148	      }
  1149	
  1150	    }
  1151	
  1152	    // If the low-nu or high-nu flux is being used, there is a correlated flux
  1153	    // for many universes of the analysis
  1154	    else{
  1155	
  1156	      // The correlated flux is constructed relative to a different CV
  1157	      MnvH1D* h_flux_special = m_fluxSystematicsMnvH1D;
  1158	      //Get bins to integrate over
  1159	      int special_b_min = h_flux_special->FindBin( min_energy );
  1160	      int special_b_max = h_flux_special->FindBin( max_energy );
  1161	      //get integral
  1162	      double int_flux_special_cv = h_flux_special->Integral(special_b_min,special_b_max,"width");
  1163	
  1164	      //CV first
  1165	      for(int i=0;i<h_flux_integrated->GetSize();i++)
  1166	        h_flux_integrated->SetBinContent(i,int_flux_special_cv);
  1167	
  1168	      // Loop over user's vertical error bands
  1169	      std::vector<std::string> vertErrorBandNames = template_hist->GetVertErrorBandNames();
  1170	      for(unsigned int k=0; k<vertErrorBandNames.size(); ++k ) {
  1171	        if(!h_flux_special->HasVertErrorBand(vertErrorBandNames[k])){continue;}
  1172	        auto correlated_flux_hists = GetVector(h_flux_integrated);
  1173	        //std::vector<THND*> correlated_flux_hists;
  1174	        MnvVertErrorBand *errBand = h_flux_special->GetVertErrorBand( vertErrorBandNames[k] );
  1175	        const int universes = errBand->GetNHists();
  1176	        for(int u=0; u<universes; ++u ) {
  1177	          // Fetch correlated flux from separate container
  1178	          TH1D* tmp_flux_special_sys = (TH1D*)errBand->GetHist(u);
  1179	          auto tmp_template = h_flux_integrated->GetCVHistoWithStatError();
  1180	          std::string tempString = Form("Flux_integrated_%s_universe_%d",vertErrorBandNames[k].c_str(),u);
  1181	          tmp_template.SetName(tempString.c_str());
  1182	          double int_flux_special_sys = tmp_flux_special_sys->Integral(special_b_min,special_b_max,"width");
  1183	          for(int i=0;i<h_flux_integrated->GetSize();i++)
  1184	            tmp_template.SetBinContent(i,int_flux_special_sys);
  1185	          correlated_flux_hists.push_back(NewHist(tmp_template));
  1186	        }
  1187	        // Push the constructed error band into the return hist
  1188	        h_flux_integrated->AddVertErrorBand(vertErrorBandNames[k],correlated_flux_hists);
  1189	      }
  1190	
  1191	      // This block can go away when MnvLatErrorBand becomes deprecated
  1192	      // Loop over user's lateral error bands
  1193	      std::vector<std::string> latErrorBandNames = template_hist->GetLatErrorBandNames();
  1194	      for(unsigned int k=0; k<latErrorBandNames.size(); ++k ) {
  1195	        if(!h_flux_special->HasVertErrorBand(latErrorBandNames[k])){continue;}
  1196	        auto correlated_flux_hists = GetVector(h_flux_integrated);
  1197	        //std::vector<THND*> correlated_flux_hists;
  1198	        MnvVertErrorBand *errBand = h_flux_special->GetVertErrorBand( latErrorBandNames[k] );
  1199	        const int universes = errBand->GetNHists();
  1200	        for(int u=0; u<universes; ++u ) {
  1201	          // Fetch correlated flux from separate container
  1202	          TH1D* tmp_flux_special_sys = (TH1D*)errBand->GetHist(u);
  1203	          auto tmp_template = h_flux_integrated->GetCVHistoWithStatError();
  1204	          std::string tempString = Form("Flux_integrated_%s_universe_%d",latErrorBandNames[k].c_str(),u);
  1205	          tmp_template.SetName(tempString.c_str());
  1206	          double int_flux_special_sys = tmp_flux_special_sys->Integral(special_b_min,special_b_max,"width");
  1207	          for(int i=0;i<h_flux_integrated->GetSize();i++)
  1208	            tmp_template.SetBinContent(i,int_flux_special_sys);
  1209	          correlated_flux_hists.push_back(NewHist(tmp_template));
  1210	        }
  1211	        // Push the constructed error band into the return hist
  1212	        h_flux_integrated->AddLatErrorBand(latErrorBandNames[k],correlated_flux_hists);
  1213	      }
  1214	
  1215	    }
  1216	    // Fill CV for any systematic universes which don't have a non-CV flux prediction
  1217	    h_flux_integrated->AddMissingErrorBandsAndFillWithCV(*template_hist);
  1218	    this->CheckAndFixFluxErrorBand(h_flux_integrated);
  1219	    return h_flux_integrated;
  1220	
  1221	  }
  1222	  template MnvH1D* FluxReweighter::GetIntegratedFluxReweighted<MnvH1D>( int nuPDG,
  1223	                                                                 MnvH1D* template_hist,
  1224	                                                                 double min_energy,
  1225	                                                                 double max_energy,
  1226	                                                                 bool use_muon_correlations);
  1227	  template MnvH2D* FluxReweighter::GetIntegratedFluxReweighted<MnvH2D>( int nuPDG,
  1228	                                                                 MnvH2D* template_hist,
  1229	                                                                 double min_energy,
  1230	                                                                 double max_energy,
  1231	                                                                 bool use_muon_correlations);
  1232	
  1233	
  1234	
  1235	  //============================================================================
  1236	  template<class MnvHistoType>
  1237	  MnvHistoType* FluxReweighter::GetIntegratedFluxReweighted_FromInputFlux(MnvH1D* input_flux,
  1238	                                                                          MnvHistoType* template_hist,
  1239	                                                                          double min_energy,
  1240	                                                                          double max_energy)
  1241	  {
  1242	    MnvH1D* h_flux = (MnvH1D*)input_flux->Clone("input_flux");
  1243	
  1244	    MnvHistoType* h_flux_integrated =
  1245	        (MnvHistoType*)template_hist->Clone("reweightedflux_integrated");
  1246	
  1247	    h_flux_integrated->ClearAllErrorBands();
  1248	    h_flux_integrated->Reset();
  1249	    //Get bins to integrate over
  1250	    int b_min = h_flux->FindBin( min_energy );
  1251	    int b_max = h_flux->FindBin( max_energy );
  1252	
  1253	    //get integral
  1254	    double flux_cv = h_flux->Integral( b_min, b_max , "width" );
  1255	    //CV first
  1256	    for(int i=0;i<h_flux_integrated->GetSize();i++)
  1257	      h_flux_integrated->SetBinContent(i,flux_cv);
  1258	
  1259	    h_flux_integrated->AddMissingErrorBandsAndFillWithCV(*template_hist);
  1260	    //h_flux_integrated->SaveAs("x_Flux_XSecLooper.root");
  1261	    return h_flux_integrated;
  1262	  }
  1263	  template MnvH1D* FluxReweighter::GetIntegratedFluxReweighted_FromInputFlux<MnvH1D>(MnvH1D* input_flux,
  1264	                                                                                     MnvH1D* template_hist,
  1265	                                                                                     double min_energy,
  1266	                                                                                     double max_energy);
  1267	  template MnvH2D* FluxReweighter::GetIntegratedFluxReweighted_FromInputFlux<MnvH2D>(MnvH1D* input_flux,
  1268	                                                                                     MnvH2D* template_hist,
  1269	                                                                                     double min_energy,
  1270	                                                                                     double max_energy);
  1271	
  1272	
  1273	  //============================================================================
  1274	  MnvH1D* FluxReweighter::GetIntegratedTargetFlux(int nuPDG, 
  1275	                                                  std::string tar_mat, 
  1276	                                                  MnvH1D* template_hist, 
  1277	                                                  double min_energy, 
  1278	                                                  double max_energy, 
  1279	                                                  std::string project_dir)
  1280	  {
  1281	    MnvH1D* h_flux = GetTargetFluxMnvH1D(nuPDG, tar_mat, project_dir);
  1282	    MnvH1D* h_flux_integrated = GetIntegratedFluxReweighted_FromInputFlux( h_flux, template_hist, min_energy, max_energy );
  1283	    
  1284	    //Put in the correct flux universes
  1285	    if( !h_flux_integrated->HasVertErrorBand("Flux") ) return h_flux_integrated;
  1286	
  1287	    MnvVertErrorBand* flux_int_band = h_flux_integrated->PopVertErrorBand("Flux");
  1288	    MnvVertErrorBand* flux_band     = h_flux->GetVertErrorBand("Flux");
  1289	
  1290	    const int nUni = flux_int_band->GetNHists();
  1291	    if( flux_int_band->GetNHists() > flux_band->GetNHists() ) 
  1292	    {
  1293	      std::cout<<"FRW: Target flux band only has "<<flux_band->GetNHists()<<" uni while hist has "<<flux_int_band->GetNHists()<<" uni"<<std::endl;
  1294	      std::exit(1);
  1295	    }
  1296	
  1297	    const int b_min = h_flux->FindBin( min_energy );
  1298	    const int b_max = h_flux->FindBin( max_energy );
  1299	    std::vector< TH1D* > flux_int_hists; 
  1300	    for( int iUni = 0; iUni < nUni; ++iUni )
  1301	    {
  1302	      TH1D* tmp_flux_uni = (TH1D*)flux_int_band->GetHist(iUni)->Clone(Form("Custom_flux_integrated_universe_%d",iUni));
  1303	      tmp_flux_uni->Clear();
  1304	
  1305	      double flux_int = flux_band->GetHist(iUni)->Integral( b_min, b_max, "width" );
  1306	      for( int iBin = 0; iBin < tmp_flux_uni->GetSize(); ++iBin ) tmp_flux_uni->SetBinContent( iBin, flux_int );
  1307	      flux_int_hists.push_back(tmp_flux_uni);
  1308	    }
  1309	
  1310	    h_flux_integrated->AddVertErrorBand("Flux",flux_int_hists);
  1311	
  1312	    return h_flux_integrated;
  1313	
  1314	  }
  1315	
  1316	  MnvH2D* FluxReweighter::GetIntegratedTargetFlux(int nuPDG, 
  1317	                                                        std::string tar_mat, 
  1318	                                                        MnvH2D* template_hist, 
  1319	                                                        double min_energy, 
  1320	                                                        double max_energy, 
  1321	                                                        std::string project_dir)
  1322	  {
  1323	    MnvH1D* h_flux = GetTargetFluxMnvH1D(nuPDG, tar_mat, project_dir);
  1324	    MnvH2D* h_flux_integrated = GetIntegratedFluxReweighted_FromInputFlux( h_flux, template_hist, min_energy, max_energy );
  1325	    
  1326	    //Put in the correct flux universes (if the hist has the Flux vert error band)
  1327	    if( !h_flux_integrated->HasVertErrorBand("Flux") ) return h_flux_integrated;
  1328	
  1329	    MnvVertErrorBand2D* flux_int_band = h_flux_integrated->PopVertErrorBand("Flux");
  1330	    MnvVertErrorBand* flux_band       = h_flux->GetVertErrorBand("Flux");
  1331	
  1332	    const int nUni = flux_int_band->GetNHists();
  1333	    if( flux_int_band->GetNHists() > flux_band->GetNHists() ) 
  1334	    {
  1335	      std::cout<<"FRW: Target flux band only has "<<flux_band->GetNHists()<<" uni while hist has "<<flux_int_band->GetNHists()<<" uni"<<std::endl;
  1336	      std::exit(1);
  1337	    }
  1338	
  1339	    const int b_min = h_flux->FindBin( min_energy );
  1340	    const int b_max = h_flux->FindBin( max_energy );
  1341	    std::vector< TH2D* > flux_int_hists; 
  1342	    for( int iUni = 0; iUni < nUni; ++iUni )
  1343	    {
  1344	      TH2D* tmp_flux_uni = (TH2D*)flux_int_band->GetHist(iUni)->Clone(Form("Custom_flux_integrated_universe_%d",iUni));
  1345	      tmp_flux_uni->Clear();
  1346	
  1347	      double flux_int = flux_band->GetHist(iUni)->Integral( b_min, b_max, "width" );
  1348	      for( int iBin = 0; iBin < tmp_flux_uni->GetSize(); ++iBin ) tmp_flux_uni->SetBinContent( iBin, flux_int );
  1349	      flux_int_hists.push_back(tmp_flux_uni);
  1350	    }
  1351	
  1352	    h_flux_integrated->AddVertErrorBand("Flux",flux_int_hists);
  1353	
  1354	    return h_flux_integrated;
  1355	  }
  1356	  //============================================================================
  1357	  MnvH1D* FluxReweighter::GetReweightedDaisySum(int nuPDG, 
  1358	                                                std::string tar_mat, 
  1359	                                                std::map<int, MnvH1D*> daisy_eff_hists, 
  1360	                                                std::string project_dir)
  1361	  {
  1362	    MnvH1D* h_param = GetDaisyParamMnvH1D( nuPDG, tar_mat, project_dir );
  1363	
  1364	    const int nBins = h_param->GetNbinsX();
  1365	    //Make sure there are the correct daisy keys
  1366	    for( int iDaisy = 0; iDaisy < nBins; ++iDaisy ) { 
  1367	      if( daisy_eff_hists.find(iDaisy) == daisy_eff_hists.end() ) {
  1368	        std::cout<<"Daisy eff hists missing daisy "<<iDaisy<<std::endl;
  1369	        std::exit(1);
  1370	      }
  1371	    }
  1372	    MnvH1D* daisy_sum = (MnvH1D*)daisy_eff_hists[0]->Clone(Form("%s_daisySum",daisy_eff_hists[0]->GetName()));
  1373	    daisy_sum->SetDirectory(0);
  1374	    daisy_sum->Reset();
  1375	    
  1376	    for( int iDaisy = 0; iDaisy < nBins; ++iDaisy ) {
  1377	      daisy_sum->Add( daisy_eff_hists[iDaisy], h_param->GetBinContent(iDaisy+1) );
  1378	    }
  1379	
  1380	    //Insert error bands from the param hist
  1381	    std::vector< std::string > vert_error_names = h_param->GetVertErrorBandNames();
  1382	    for( auto& name : vert_error_names ) {
  1383	      MnvVertErrorBand* error_band = h_param->GetVertErrorBand(name);
  1384	      const int nHists = error_band->GetNHists();
  1385	      daisy_sum->AddVertErrorBand(name, nHists);
  1386	
  1387	      for( uint iHist = 0; iHist < error_band->GetNHists(); ++iHist){
  1388	        for( int iDaisy = 0; iDaisy < nBins; ++iDaisy ) {
  1389	          daisy_sum->GetVertErrorBand(name)->GetHist(iHist)->Add( daisy_eff_hists[iDaisy], 
  1390	                          error_band->GetHist(iHist)->GetBinContent(iDaisy+1) );
  1391	        }
  1392	      }
  1393	    }
  1394	    return daisy_sum;
  1395	  }
  1396	
  1397	  MnvH2D* FluxReweighter::GetReweightedDaisySum(int nuPDG, 
  1398	                                                std::string tar_mat, 
  1399	                                                std::map<int, MnvH2D*> daisy_eff_hists, 
  1400	                                                std::string project_dir)
  1401	  {
  1402	    MnvH1D* h_param = GetDaisyParamMnvH1D( nuPDG, tar_mat, project_dir );
  1403	
  1404	    const int nBins = h_param->GetNbinsX();
  1405	    //Make sure there are the correct daisy keys
  1406	    for( int iDaisy = 0; iDaisy < nBins; ++iDaisy ) { 
  1407	      if( daisy_eff_hists.find(iDaisy) == daisy_eff_hists.end() ) {
  1408	        std::cout<<"Daisy eff hists missing daisy "<<iDaisy<<std::endl;
  1409	        std::exit(1);
  1410	      }
  1411	    }
  1412	    MnvH2D* daisy_sum = (MnvH2D*)daisy_eff_hists[0]->Clone(Form("%s_daisySum",daisy_eff_hists[0]->GetName()));
  1413	    daisy_sum->SetDirectory(0);
  1414	    daisy_sum->Reset();
  1415	    
  1416	    for( int iDaisy = 0; iDaisy < nBins; ++iDaisy ) {
  1417	      daisy_sum->Add( daisy_eff_hists[iDaisy], h_param->GetBinContent(iDaisy+1) );
  1418	    }
  1419	
  1420	    //Insert error bands from the param hist
  1421	    std::vector< std::string > vert_error_names = h_param->GetVertErrorBandNames();
  1422	    for( auto& name : vert_error_names ) {
  1423	      MnvVertErrorBand* error_band = h_param->GetVertErrorBand(name);
  1424	      const int nHists = error_band->GetNHists();
  1425	      daisy_sum->AddVertErrorBand(name, nHists);
  1426	
  1427	      for( uint iHist = 0; iHist < error_band->GetNHists(); ++iHist){
  1428	        for( int iDaisy = 0; iDaisy < nBins; ++iDaisy ) {
  1429	          daisy_sum->GetVertErrorBand(name)->GetHist(iHist)->Add( daisy_eff_hists[iDaisy], 
  1430	                          error_band->GetHist(iHist)->GetBinContent(iDaisy+1) );
  1431	        }
  1432	      }
  1433	    }
  1434	    return daisy_sum;
  1435	  }
  1436	  //============================================================================
  1437	  double FluxReweighter::GetFluxErrorWeight( double Enu, int nuPDG,
  1438	                                             unsigned int universe )
  1439	  {
  1440	    if ( universe >= m_nFluxUniverses )
  1441	    {
  1442	      std::cout << Form( "Flux universe %d requested.  FluxReweighter has universes 0-%d",
  1443	                          universe, m_nFluxUniverses - 1 )
  1444	                << std::endl;
  1445	      std::exit(1);
  1446	    }
  1447	    MnvH1D* newFlux = nuPDG > 0 ? m_fluxReweightNu : m_fluxReweightNubar;
  1448	    double univFluxVal =
  1449	        newFlux->GetVertErrorBand( m_fluxErrorName )->GetHist( universe )->Interpolate( Enu );
  1450	
  1451	
  1452	    double num = univFluxVal;
  1453	    double dem = newFlux->Interpolate( Enu );
  1454	
  1455	    if(Enu>75.){//Condition to avoid the large slope at large Enu which causes crazy weights. Slope in that region is 10^-22 or so
  1456	      num = newFlux->GetVertErrorBand( m_fluxErrorName )->GetHist( universe )->GetBinContent(newFlux->FindBin(Enu));
  1457	      dem = newFlux->GetBinContent(newFlux->FindBin(Enu));
  1458	    }
  1459	    if (num ==0 ||dem ==0) {
  1460	      //      std::cout << " I have the following num and denominator " << num << "\t" << dem << std::endl;
  1461	      return 1;
  1462	    }
  1463	    return  num/dem;
  1464	  }
  1465	
  1466	
  1467	  //============================================================================
  1468	  std::vector<double> FluxReweighter::GetFluxErrorWeights(double Enu, int nuPDG)
  1469	  {
  1470	    std::vector<double> weights;
  1471	    for ( unsigned int iuniv = 0; iuniv < m_nFluxUniverses; ++iuniv )
  1472	    {
  1473	      weights.push_back( GetFluxErrorWeight(Enu, nuPDG, iuniv) );
  1474	    }
  1475	    return weights;
  1476	  }
  1477	
  1478	
  1479	  //============================================================================
  1480	  template<class MnvHistoType>
  1481	    void FluxReweighter::AddFluxErrorBand( MnvHistoType* h )
  1482	    {
  1483	      if ( !h->AddVertErrorBand( m_fluxErrorName, m_nFluxUniverses ) )
  1484	      {
  1485	        std::cout << Form( "Could not add flux error band to histogram \"%s\"",
  1486	                           h->GetName() ) << std::endl;
  1487	        std::exit(1);
  1488	      }
  1489	      PropagateNuEConstraintWeights( h );
  1490	    }
  1491	  template void FluxReweighter::AddFluxErrorBand<MnvH1D>( MnvH1D* h );
  1492	  template void FluxReweighter::AddFluxErrorBand<MnvH2D>( MnvH2D* h );
  1493	
  1494	
  1495	  //============================================================================
  1496	  template<class MnvHistoType>
  1497	    bool FluxReweighter::CheckFluxErrorBand( MnvHistoType* h )
  1498	    {
  1499	      if (h->GetVertErrorBand(m_fluxErrorName)->GetUnivWgts()) return true; //There are weights
  1500	      else return false;
  1501	    }
  1502	  template bool FluxReweighter::CheckFluxErrorBand<MnvH1D>( MnvH1D* h );
  1503	  template bool FluxReweighter::CheckFluxErrorBand<MnvH2D>( MnvH2D* h );
  1504	
  1505	  //============================================================================
  1506	  template<class MnvHistoType>
  1507	  void FluxReweighter::CheckAndFixFluxErrorBand( MnvHistoType* h )
  1508	    {
  1509	      if (!h->GetVertErrorBand(m_fluxErrorName)->GetUnivWgts())
  1510	        PropagateNuEConstraintWeights( h );
  1511	    }
  1512	  template void FluxReweighter::CheckAndFixFluxErrorBand<MnvH1D>( MnvH1D* h );
  1513	  template void FluxReweighter::CheckAndFixFluxErrorBand<MnvH2D>( MnvH2D* h );
  1514	
  1515	
  1516	  //============================================================================
  1517	  void FluxReweighter::TruncateNumberOfFluxUniverses( MnvH1D* h, int nUniverses)
  1518	  {
  1519	    MnvVertErrorBand *poppedFluxErrorBand = h->PopVertErrorBand("Flux");
  1520	    std::vector<TH1D*> fluxUniverses = poppedFluxErrorBand->GetHists();
  1521	    fluxUniverses.resize(nUniverses);
  1522	    h->AddVertErrorBand("Flux",fluxUniverses);
  1523	    CheckAndFixFluxErrorBand(h);
  1524	  }
  1525	
  1526	
  1527	  //============================================================================
  1528	  void FluxReweighter::FillFluxErrorBand( MnvH1D* h, double val,
  1529	                                          double cvweight, double Enu,
  1530	                                          int nuPDG )
  1531	  {
  1532	    if ( !IsFluxErrorBandOK( h ) ) std::exit(1);
  1533	    std::vector<double> fluxErrorWeights = GetFluxErrorWeights(Enu, nuPDG);
  1534	    double cvWeightFromMe = 1.0;
  1535	    if ( !h->FillVertErrorBand( m_fluxErrorName, val, fluxErrorWeights,
  1536	                                cvweight, cvWeightFromMe ) )
  1537	    {
  1538	      std::cout << Form( "Could not fill flux error band for MnvH1D \"%s\"",
  1539	                         h->GetName() )
  1540	                << std::endl;
  1541	      std::exit(1);
  1542	    }
  1543	    PropagateNuEConstraintWeights( h );
  1544	  }
  1545	
  1546	
  1547	  //===========================================================================
  1548	  void FluxReweighter::FillFluxErrorBand( MnvH2D* h, double xval, double yval,
  1549	                                          double cvweight, double Enu,
  1550	                                          int nuPDG )
  1551	  {
  1552	    if ( !IsFluxErrorBandOK( h ) ) std::exit(1);
  1553	    std::vector<double> fluxErrorWeights = GetFluxErrorWeights(Enu, nuPDG);
  1554	    double cvWeightFromMe = 1.0;
  1555	    if ( !h->FillVertErrorBand( m_fluxErrorName, xval, yval, fluxErrorWeights,
  1556	                                cvweight, cvWeightFromMe ) )
  1557	    {
  1558	      std::cout << Form( "Could not fill flux error band for MnvH2D \"%s\"",
  1559	                         h->GetName() )
  1560	                << std::endl;
  1561	      std::exit(1);
  1562	    }
  1563	    PropagateNuEConstraintWeights( h );
  1564	  }
  1565	
  1566	
  1567	  //============================================================================
  1568	  template<class MnvHistoType>
  1569	    bool FluxReweighter::IsFluxErrorBandOK( MnvHistoType* h )
  1570	    {
  1571	      if ( !h->HasVertErrorBand( m_fluxErrorName ) )
  1572	      {
  1573	        std::cout << Form( "Flux error band not found for histogram \"%s\"",
  1574	                           h->GetName() )
  1575	                  << std::endl;
  1576	        return false;
  1577	      }
  1578	      else if ( h->GetVertErrorBand( m_fluxErrorName )->GetNHists() !=
  1579	                m_nFluxUniverses )
  1580	      {
  1581	        std::cout << Form( "Histogram \"%s\" has %d flux universes. Exactly %d required",
  1582	                           h->GetName(),
  1583	                           h->GetVertErrorBand( m_fluxErrorName )->GetNHists(),
  1584	                           m_nFluxUniverses )
  1585	                  << std::endl;
  1586	        return false;
  1587	      }
  1588	      else return true;
  1589	    }
  1590	  template bool FluxReweighter::IsFluxErrorBandOK<MnvH1D>( MnvH1D* h );
  1591	  template bool FluxReweighter::IsFluxErrorBandOK<MnvH2D>( MnvH2D* h );
  1592	
  1593	
  1594	  //============================================================================
  1595	  template<class MnvHistoType>
  1596	    void FluxReweighter::PropagateNuEConstraintWeights( MnvHistoType* h )
  1597	    {
  1598	      if ( m_applyNuEConstraint &&
  1599	           fabs( h->GetVertErrorBand( m_fluxErrorName )->GetUnivWgt(0) -
  1600	             m_fluxReweightNu_Ref->GetVertErrorBand( m_fluxErrorName )->GetUnivWgt(0) ) > 1.0e-6 )
  1601	      {
  1602	        //std::cout << Form( "Propagating v+e constraint weights to flux error band of histogram \"%s\"",
  1603	        //                     h->GetName() )
  1604	        //            << std::endl;
  1605	        for ( unsigned int iuniv = 0; iuniv < m_nFluxUniverses; ++iuniv )
  1606	        {
  1607	          h->GetVertErrorBand( m_fluxErrorName )->SetUnivWgt( iuniv,
  1608	              m_fluxReweightNu_Ref->GetVertErrorBand( m_fluxErrorName )->GetUnivWgt( iuniv ) );
  1609	        }
  1610	      }
  1611	      else {
  1612	        //std::cout << "I'm inside PropagateNuEConstraintWeights, "
  1613	        //          << "but I didn't satisfy the condition to apply the "
  1614	        //          << "weights..."
  1615	        //          << std::endl;
  1616	      }
  1617	    }
  1618	  template void FluxReweighter::PropagateNuEConstraintWeights<MnvH1D>( MnvH1D* h );
  1619	  template void FluxReweighter::PropagateNuEConstraintWeights<MnvH2D>( MnvH2D* h );
  1620	
  1621	
  1622	  //============================================================================
  1623	  const char* FluxReweighter::g4NumiVersionString(EG4NumiVersion v)
  1624	  {
  1625	    switch(v) {
  1626	      case g4numiv5: // This also handles "eroica"
  1627	        return "g4numiv5";
  1628	      case g4numiv6:
  1629	        return "g4numiv6";
  1630	      default:
  1631	        std::cerr << "No g4numi version " << v << std::endl;
  1632	        std::exit(1);
  1633	    }
  1634	  }
  1635	
  1636	
  1637	  //======================================================================
  1638	  const char* FluxReweighter::fluxForSystematicsHistName(EFluxVersion fluxVersion)
  1639	  {
  1640	    int iPlaylist = LeOrMe(d_Playlist); // Adding in Amit's CVS commit 1.106-8 changes -David L.
  1641	    switch(fluxVersion){
  1642	      case lowNu:
  1643	        m_useStandardFlux = false;
  1644	        return "lowNuFlux_MnvH1D";
  1645	      case highNu:
  1646	        m_useStandardFlux = false;
  1647	        return "highNuFlux_MnvH1D";
  1648	      case ppfxDebug:
  1649	        m_useStandardFlux = false;
  1650	        return "ppfxDebugFlux_MnvH1D";
  1651	      case comboPPFXHighNu:
  1652		m_useStandardFlux = false;
  1653		return "comboPPFXHighNuFlux_MnvH1D";
  1654	
  1655	      default:
  1656	        m_useStandardFlux = true;
  1657		if (iPlaylist==3) return "MuonBar_Energy_MnvH1D"; // Adding in Amit's CVS commit 1.106-8 changes -David L.
  1658		else return "Muon_Energy_MnvH1D";
  1659	    }
  1660	  }
  1661	
  1662	
  1663	  //======================================================================
  1664	  bool FluxReweighter::IsCustomFlux(EFluxVersion fluxVersion)
  1665	  {
  1666	    switch(fluxVersion){
  1667	      case lowNu:
  1668	        return true;
  1669	      case highNu:
  1670	        return true;
  1671	      case ppfxDebug:
  1672	        return true;
  1673	      case comboPPFXHighNu:
  1674		return true;
  1675	      default:
  1676	        return false;
  1677	    }
  1678	  }
  1679	
  1680	
  1681	  //======================================================================
  1682	  const char* FluxReweighter::playlistString(EPlaylist p)
  1683	  {
  1684	    switch(p) {
  1685	      case minerva1:
  1686	        return "minerva1";
  1687	      case minerva5:
  1688	        return "minerva5";
  1689	      case minerva7:
  1690	        return "minerva1";
  1691	      case minerva9:
  1692	        return "minerva1";
  1693	      case minerva13:
  1694	        return "minerva13";
  1695	      case minerva2p2h:
  1696	        return "minerva13";
  1697	      case minervaLE_FHC:
  1698	        return "minervaLE-FHC";
  1699	      case minervame1A:
  1700	        return "minervame1D";
  1701	      case minervame1B:
  1702	        return "minervame1D";
  1703	      case minervame1C:
  1704	        return "minervame1D";
  1705	      case minervame1D:
  1706	        return "minervame1D";
  1707	      case minervame1E:
  1708	        return "minervame1D";
  1709	      case minervame1F:
  1710	        return "minervame1D";
  1711	      case minervame1N:
  1712	        return "minervame1N";
  1713	      case minervame1O:
  1714	        return "minervame1N";
  1715	      case minervame1P:
  1716	        return "minervame1N";
  1717	      case minervame1G:
  1718	        return "minervame1M";
  1719	      case minervame1L:
  1720	        return "minervame1M";
  1721	      case minervame1M:
  1722	        return "minervame1M";
  1723	      case minervame1D1M1NWeightedAve:
  1724	        return "minervame1D1M1NWeightedAve";
  1725	      case minervame5A:
  1726	        return "minervame5A";
  1727	      case minervame6A:
  1728	        return "minervame6A";
  1729	      case minervame6B:
  1730	        return "minervame6B";
  1731	      case minervame6C:
  1732	        return "minervame6C";
  1733	      case minervame6D:
  1734	        return "minervame6D";
  1735	      case minervame6E:
  1736	        return "minervame6E";
  1737	      case minervame6F:
  1738	        return "minervame6F";
  1739	      case minervame6G:
  1740	      	return "minervame6G";
  1741	      case minervame6H:
  1742	      	return "minervame6H";
  1743	      case minervame6I:
  1744	      	return "minervame6I";
  1745	      case minervame6J:
  1746	      	return "minervame6J";
  1747	      default:
  1748	        std::cerr << "No playlist enum " << p << std::endl;
  1749	        std::exit(1);
  1750	    }
  1751	  }
  1752	
  1753	
  1754	  //============================================================================
  1755	  int FluxReweighter::LeOrMe(EPlaylist p) {
  1756	    /*
  1757	     *
  1758	     * Given a playlist enum it returns an integer value
  1759	     * corresponding to Playlist of LE or ME.
  1760	     * All LE should return 1
  1761	     * ME will return 2
  1762	     * This is to keep a future provision if the
  1763	     * weight factors to be implimented playlist by playlist
  1764	     * or in a group set different integers other than 1, 2
  1765	     */
  1766	    switch(p) {
  1767	      case minerva1:
  1768	        return 1;
  1769	      case minerva5:
  1770	        return 1;
  1771	      case minerva13:
  1772	        return 1;
  1773	      case minervaLE_FHC:
  1774	        return 1;
  1775	      case minervame1A:
  1776	        return 2;
  1777	      case minervame1B:
  1778	        return 2;
  1779	      case minervame1C:
  1780	        return 2;
  1781	      case minervame1D:
  1782	        return 2;
  1783	      case minervame1E:
  1784	        return 2;
  1785	      case minervame1F:
  1786	        return 2;
  1787	      case minervame1G:
  1788	        return 2;
  1789	      case minervame1L:
  1790	        return 2;
  1791	      case minervame1M:
  1792	        return 2;
  1793	      case minervame1N:
  1794	        return 2;
  1795	      case minervame1O:
  1796	        return 2;
  1797	      case minervame1P:
  1798	        return 2;
  1799	      case minervame1D1M1NWeightedAve:
  1800	        return 2;
  1801	      case minervame5A:
  1802	        return 3;
  1803	      case minervame6A:
  1804	        return 3;
  1805	      case minervame6B:
  1806	      	return 3;
  1807	      case minervame6C:
  1808	      	return 3;
  1809	      case minervame6D:
  1810	      	return 3;
  1811	      case minervame6E:
  1812	        return 3;
  1813	      case minervame6F:
  1814	      	return 3;
  1815	      case minervame6G:
  1816	      	return 3;
  1817	      case minervame6H:
  1818	      	return 3;
  1819	      case minervame6I:
  1820	      	return 3;
  1821	      case minervame6J:
  1822	      	return 3;
  1823	      default:
  1824	        std::cerr << "No playlist enum " << p << std::endl;
  1825	        std::exit(1);
  1826	    }
  1827	  }
  1828	
  1829	
  1830	
  1831	  //============================================================================
  1832	  FluxReweighter::EPlaylist FluxReweighter::GetPlaylistEnum(std::string& playlist)
  1833	  {
  1834	    // case-independent
  1835	    std::transform(playlist.begin(), playlist.end(), playlist.begin(), ::tolower);
  1836	
  1837	    //std::cout << "Looking for a flux reweighter with the playlist "
  1838	    //          << playlist << std::endl;
  1839	
  1840	    if ( playlist.compare("minerva1")== 0 )
  1841	      return minerva1;
  1842	    if( playlist.compare("minerva5")== 0 )
  1843	      return minerva5;
  1844	    if ( playlist.compare("minerva7")== 0 )
  1845	      return minerva1;
  1846	    if ( playlist.compare("minerva9")== 0 )
  1847	      return minerva1;
  1848	    if ( playlist.compare("minerva13")== 0 )
  1849	      return minerva13;
  1850	    if ( playlist.compare("minerva13c")== 0 )
  1851	      return minerva13;
  1852	    if ( playlist.compare("minerva13e")== 0 )
  1853	      return minerva13;
  1854	    if ( playlist.compare("minerva2p2h")== 0 )
  1855	      return minerva13;
  1856	    if( playlist.compare("minervame1a")== 0)
  1857	      return minervame1D;
  1858	    if( playlist.compare("minervame1b")== 0)
  1859	      return minervame1D;
  1860	    if( playlist.compare("minervame1c")== 0)
  1861	      return minervame1D;
  1862	    if( playlist.compare("minervame1d")== 0)
  1863	      return minervame1D;
  1864	    if( playlist.compare("minervame1e")== 0)
  1865	      return minervame1D;
  1866	    if( playlist.compare("minervame1f")== 0)
  1867	      return minervame1D;
  1868	    if( playlist.compare("minervame1g")== 0)
  1869	      return minervame1M;
  1870	    if( playlist.compare("minervame1l")== 0)
  1871	      return minervame1M;
  1872	    if( playlist.compare("minervame1m")== 0)
  1873	      return minervame1M;
  1874	    if( playlist.compare("minervame1n")== 0)
  1875	      return minervame1N;
  1876	    if( playlist.compare("minervame1o")== 0)
  1877	      return minervame1N;
  1878	    if( playlist.compare("minervame1p")== 0)
  1879	      return minervame1N;
  1880	    if ( playlist.compare("minervame1d1m1nweightedave")== 0)
  1881	      return minervame1D1M1NWeightedAve;
  1882	    if( playlist.compare("minervame5a")== 0)
  1883	      return minervame5A;
  1884	    if( playlist.compare("minervame6a")== 0)
  1885	      return minervame6A;
  1886	    if( playlist.compare("minervame6b")== 0)
  1887	      return minervame6A;
  1888	    if( playlist.compare("minervame6c")== 0)
  1889	      return minervame6A;
  1890	    if( playlist.compare("minervame6d")== 0)
  1891	      return minervame6A;
  1892	    if( playlist.compare("minervame6e")== 0)
  1893	      return minervame6A;
  1894	    if( playlist.compare("minervame6f")== 0)
  1895	      return minervame6A;
  1896	    if( playlist.compare("minervame6g")== 0)
  1897	      return minervame6A;
  1898	    if( playlist.compare("minervame6h")== 0)
  1899	      return minervame6A;
  1900	    if( playlist.compare("minervame6i")== 0)
  1901	      return minervame6A;
  1902	    if( playlist.compare("minervame6j")== 0)
  1903	      return minervame6A;
  1904	    std::cerr << "No playlist enum " << playlist << std::endl;
  1905	    std::exit(1);
  1906	  }
  1907	
  1908	
  1909	  //============================================================================
  1910	  const char* FluxReweighter::fluxVersionString(EFluxVersion f)
  1911	  {
  1912	    switch(f) {
  1913	      case gen1:
  1914	        return "gen1";
  1915	      case gen2thick:
  1916	        return "gen2thick";
  1917	      case gen2thin:
  1918	        return "gen2thin";
  1919	      case lowNu:
  1920	        return "lowNu";
  1921	      case highNu:
  1922	        return "highNu";
  1923	      case ppfxDebug:
  1924	        return "ppfxDebug";
  1925	      case comboPPFXHighNu:
  1926	        return "comboPPFXHighNu";
  1927	      default:
  1928	        std::cerr << "No flux version " << f << std::endl;
  1929	        std::exit(1);
  1930	    }
  1931	  }
  1932	
  1933	  FluxReweighter& flux_reweighter(std::string plist, int nu_pdg,
  1934	                                  bool use_nuE_constraint, int n_flux_universes /*= 200*/) {
  1935	    static std::map<std::string, std::map<int, PlotUtils::FluxReweighter*> > FRW_map;
  1936	    std::transform(plist.begin(), plist.end(), plist.begin(), ::tolower);
  1937	    if (!FRW_map[plist][abs(nu_pdg)]) {
  1938	      FRW_map[plist][abs(nu_pdg)] = _flux_reweighter(plist, nu_pdg,
  1939	                                                     use_nuE_constraint,n_flux_universes);
  1940	    }
  1941	    return *(FRW_map[plist][abs(nu_pdg)]);
  1942	  }
  1943	
  1944	} // end namespace PlotUtils
  1945	
  1946	// Local Variables:
  1947	// c-basic-offset: 2
  1948	// End:
